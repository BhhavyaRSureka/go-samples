// ********RoostGPT********
/*
Test generated by RoostGPT for test PublicRepoTest using AI Type Open AI and AI Model gpt-4

1. Test when points a and b are the same. In this case, the distance returned should be 0.
2. Test when point a is at the origin (0, 0) and point b is at some arbitrary point (x, y). The distance returned should be the same as the magnitude of point b.
3. Test when point a is at some arbitrary point (x, y) and point b is at the origin (0, 0). The distance returned should be the same as the magnitude of point a.
4. Test when points a and b are at arbitrary different points. The distance returned should be the correct Euclidean distance between two points.
5. Test when points a and b are at arbitrary points with negative coordinates. The distance returned should still be a positive value and should be the correct Euclidean distance.
6. Test when one or both of the points are null. The function should handle this gracefully.
7. Test when points a and b are at points with extremely large values. This should test if the function can handle large numbers and still return the correct distance.
8. Test when points a and b are at points with extremely small values, including zero. This should test if the function can handle small numbers and still return the correct distance.
9. Test when points a and b are at points with decimal values. The function should correctly calculate the distance.
10. Test when points a and b have some of their coordinates as NaN or Infinity. The function should handle these cases properly.
*/

// ********RoostGPT********
package geometry

import (
	"math"
	"testing"
)

func TestDistance_3fc242e7c9(t *testing.T) {
	tests := []struct {
		name     string
		a        *Point
		b        *Point
		expected float64
	}{
		{
			name:     "Same points",
			a:        &Point{1, 1},
			b:        &Point{1, 1},
			expected: 0,
		},
		{
			name:     "Point A at origin",
			a:        &Point{0, 0},
			b:        &Point{3, 4},
			expected: 5,
		},
		{
			name:     "Point B at origin",
			a:        &Point{3, 4},
			b:        &Point{0, 0},
			expected: 5,
		},
		{
			name:     "Arbitrary different points",
			a:        &Point{1, 2},
			b:        &Point{4, 6},
			expected: 5,
		},
		{
			name:     "Negative coordinates",
			a:        &Point{-1, -2},
			b:        &Point{-4, -6},
			expected: 5,
		},
		{
			name:     "Null points",
			a:        nil,
			b:        nil,
			expected: math.NaN(),
		},
		{
			name:     "Large values",
			a:        &Point{1e50, 1e60},
			b:        &Point{1e50, 1e60},
			expected: 0,
		},
		{
			name:     "Small values",
			a:        &Point{1e-50, 1e-60},
			b:        &Point{1e-50, 1e-60},
			expected: 0,
		},
		{
			name:     "Decimal values",
			a:        &Point{1.1, 2.2},
			b:        &Point{4.4, 6.6},
			expected: 5.8314446864,
		},
		{
			name:     "NaN and Infinity values",
			a:        &Point{math.NaN(), math.Inf(1)},
			b:        &Point{math.NaN(), math.Inf(1)},
			expected: math.NaN(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Distance(tt.a, tt.b); !almostEqual(got, tt.expected) {
				t.Errorf("Distance() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func almostEqual(a, b float64) bool {
	return math.Abs(a-b) <= 1e-9
}
