// ********RoostGPT********
/*
Test generated by RoostGPT for test PublicRepoTest using AI Type Open AI and AI Model gpt-4

1. Test when points a and b are the same. In this case, the distance returned should be 0.
2. Test when point a is at the origin (0,0) and point b is at some arbitrary point (x, y). The expected distance should be the square root of x^2 + y^2.
3. Test when point b is at the origin and point a is at some arbitrary point. The expected distance should be the same as the previous scenario.
4. Test when both points a and b are at arbitrary points. In this case, the distance should be the square root of the sum of the squares of the differences in the x and y coordinates.
5. Test when the coordinates of points a and b are negative. The distance should still be a positive value.
6. Test when the coordinates of points a and b are both positive and negative. The distance should still be a positive value.
7. Test when the coordinates of points a and b are fractions. The distance should be calculated correctly.
8. Test when the coordinates of points a and b are very large numbers. The function should be able to handle these inputs without overflowing.
9. Test when the coordinates of points a and b are very small numbers. The function should be able to handle these inputs without underflowing.
10. Test when the coordinates of points a and b are NaN (Not a Number). The function should return NaN.
11. Test when the coordinates of points a and b are Inf (Infinity). The function should return Inf.
12. Test when the coordinates of points a and b are a mix of NaN and Inf. The function should return NaN.
13. Test when one or both of points a and b is nil. The function should return an appropriate error or NaN.
*/

// ********RoostGPT********
package geometry

import (
	"math"
	"testing"
)

func TestDistance_3fc242e7c9(t *testing.T) {
	tests := []struct {
		name    string
		a, b    *Point
		want    float64
		wantErr bool
	}{
		{
			name: "Test when points a and b are the same",
			a:    &Point{X: 1, Y: 1},
			b:    &Point{X: 1, Y: 1},
			want: 0,
		},
		{
			name: "Test when point a is at the origin and point b is at some arbitrary point",
			a:    &Point{X: 0, Y: 0},
			b:    &Point{X: 3, Y: 4},
			want: 5,
		},
		{
			name: "Test when point b is at the origin and point a is at some arbitrary point",
			a:    &Point{X: 3, Y: 4},
			b:    &Point{X: 0, Y: 0},
			want: 5,
		},
		{
			name: "Test when both points a and b are at arbitrary points",
			a:    &Point{X: 1, Y: 2},
			b:    &Point{X: 4, Y: 6},
			want: 5,
		},
		{
			name: "Test when the coordinates of points a and b are negative",
			a:    &Point{X: -1, Y: -2},
			b:    &Point{X: -4, Y: -6},
			want: 5,
		},
		{
			name: "Test when the coordinates of points a and b are both positive and negative",
			a:    &Point{X: -1, Y: 2},
			b:    &Point{X: 4, Y: -6},
			want: math.Sqrt(26),
		},
		{
			name: "Test when the coordinates of points a and b are fractions",
			a:    &Point{X: 0.5, Y: 0.5},
			b:    &Point{X: 1.5, Y: 1.5},
			want: math.Sqrt(2),
		},
		{
			name: "Test when the coordinates of points a and b are very large numbers",
			a:    &Point{X: 1e6, Y: 1e6},
			b:    &Point{X: 1e6 + 3, Y: 1e6 + 4},
			want: 5,
		},
		{
			name: "Test when the coordinates of points a and b are very small numbers",
			a:    &Point{X: 1e-6, Y: 1e-6},
			b:    &Point{X: 1e-6 + 3e-6, Y: 1e-6 + 4e-6},
			want: 5e-6,
		},
		{
			name: "Test when the coordinates of points a and b are NaN",
			a:    &Point{X: math.NaN(), Y: math.NaN()},
			b:    &Point{X: math.NaN(), Y: math.NaN()},
			want: math.NaN(),
		},
		{
			name: "Test when the coordinates of points a and b are Inf",
			a:    &Point{X: math.Inf(1), Y: math.Inf(1)},
			b:    &Point{X: math.Inf(1), Y: math.Inf(1)},
			want: math.NaN(),
		},
		{
			name: "Test when the coordinates of points a and b are a mix of NaN and Inf",
			a:    &Point{X: math.NaN(), Y: math.Inf(1)},
			b:    &Point{X: math.Inf(1), Y: math.NaN()},
			want: math.NaN(),
		},
		{
			name:    "Test when one or both of points a and b is nil",
			a:       nil,
			b:       &Point{X: 1, Y: 1},
			want:    math.NaN(),
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Distance(tt.a, tt.b); !math.IsNaN(got) && got != tt.want || math.IsNaN(got) && !math.IsNaN(tt.want) {
				t.Errorf("Distance() = %v, want %v", got, tt.want)
			}
		})
	}
}
