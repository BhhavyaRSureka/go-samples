// ********RoostGPT********
/*
Test generated by RoostGPT for test PublicRepoTest using AI Type Open AI and AI Model gpt-4

1. Scenario: Test with a point located at the origin (0,0). This will check if the function can handle the simplest case correctly.

2. Scenario: Test with a point located away from the origin. This will check if the function can calculate the distance correctly when the point is not at the origin.

3. Scenario: Test with an equation where all coefficients are zero. This will check if the function can handle edge cases and whether it can avoid division by zero.

4. Scenario: Test with an equation where the coefficients are very large. This will check if the function can handle large numbers and if it can avoid overflow.

5. Scenario: Test with an equation where the coefficients are very small (but not zero). This will check if the function can handle very small numbers and avoid underflow.

6. Scenario: Test with a point located in each of the four quadrants. This will check if the function can handle positive and negative coordinates.

7. Scenario: Test with a point and equation that are known to result in a specific distance. This will check if the function can calculate the distance correctly.

8. Scenario: Test with a null point. This will check if the function can handle null inputs correctly.

9. Scenario: Test with a negative point. This will check if the function can handle negative coordinates. 

10. Scenario: Test with a point and equation that should result in a zero distance. This will check if the function can handle cases where the point lies on the line described by the equation.
*/

// ********RoostGPT********
package geometry

import (
	"math"
	"testing"
)

func TestPointDistance_f08e35a65d(t *testing.T) {
	type args struct {
		p        *Point
		equation [3]float64
	}
	tests := []struct {
		name string
		args args
		want float64
	}{
		{"Origin", args{&Point{0, 0}, [3]float64{1, 1, 1}}, 0.70710678118},
		{"Away from origin", args{&Point{3, 4}, [3]float64{1, 2, 3}}, 1.3416407865},
		{"Zero coefficients", args{&Point{3, 4}, [3]float64{0, 0, 0}}, 0},
		{"Large coefficients", args{&Point{3, 4}, [3]float64{1e6, 2e6, 3e6}}, 1.3416407865},
		{"Small coefficients", args{&Point{3, 4}, [3]float64{1e-6, 2e-6, 3e-6}}, 1.3416407865},
		{"Four quadrants", args{&Point{-3, -4}, [3]float64{1, 2, 3}}, 1.3416407865},
		{"Known distance", args{&Point{3, 4}, [3]float64{1, 2, 3}}, 1.3416407865},
		{"Null point", args{nil, [3]float64{1, 2, 3}}, math.NaN()},
		{"Negative point", args{&Point{-3, -4}, [3]float64{1, 2, 3}}, 1.3416407865},
		{"Zero distance", args{&Point{3, 4}, [3]float64{1, -1, -1}}, 0},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := PointDistance(tt.args.p, tt.args.equation); math.Abs(got-tt.want) > 1e-9 {
				t.Errorf("PointDistance() = %v, want %v", got, tt.want)
			}
		})
	}
}
